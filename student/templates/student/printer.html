{% extends 'base.html' %}
{% load static %}

{% block page_title %}Printer{% endblock %}

{% block content %}
    {% include 'components/navbar.html' %}
    {{user | json_script:"user-data"}}
    <div class="job-reservations full-width-container" id="job-reservations">
        
        <!-- RESERVATION MODAL BELOW -->

        <div class="ReservationModal" v-if="modalVisibility">
            <div class="ReservationModalContent">
              <div class="ModalTitle header3">New Reservation</div>
    
              <div class="FormContainer">
    
                <div class="ModalRow">
                  <div class="ModalColumn subtitle1">Filename</div>
                  <input class="ModalColumn modalInput" placeholder="filename / description" ref="filename" v-model="filename">
                </div>
                
                <div class="ModalRow">
                  <div class="ModalColumn subtitle1">Print Time</div>
                  <div class="ModalColumn">
                    <div class="ModalRow">
                      <div class="ModalColumn">
                        <div v-if="estimating" class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
                        <input v-if="!estimating" class="modalInput timeInput" ref="hours" v-model="hours" placeholder="0">
                      </div>
                      <div class="ModalColumn timeTitle">
                        hours
                      </div>
                      <div class="ModalColumn">
                        <div v-if="estimating" class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
                        <input v-if="!estimating" class="modalInput timeInput" ref="minutes" v-model="minutes" placeholder="0">
                      </div>
                      <div class="ModalColumn timeTitle">
                        mins
                      </div>
    
                    </div>
                    <div class="ModalRow">
                      <button class="button small" :disabled="lines==='' || estimating" @click="estimatePrintTime"><span>Estimate Time</span></button>
                      <!-- <button v-if="estimating" class="button small" @click="cancelEstimate"><span>Cancel Estimate</span></button> -->
                    </div>
                  </div>
                </div>
                
                <div class="ModalRow">
                  <div class="ModalColumn subtitle1">Course Related</div>
                  <div class="ModalColumn">
                    <input type="checkbox" class="checked" id="is_course_related" v-model="courseRelated">
                  </div>
                </div>
                
                <div class="ModalRow">
                  <button class="button fluid" :disabled="duration==-1" @click="proceedToPlacement"><span>Continue</span></button>
                </div>
                <div class="ModalRow lastFlexItem">
                  <button class="button secondary fluid" @click="hideModal"><span>Cancel</span></button>
                </div>
                
              </div>
    
            </div>
          </div>

        <!-- RESERVATION MODAL ABOVE -->

        <div class="HorizontalScrollingContainer" id="ScrollingContainer">

            <div class="TimeContainer">
                <div class="TimeElement" v-bind:key="time.id" v-for="time in timeline">
                    <div class="Day">[{time.date}]</div>
                    <div class="Time">[{time.time}]</div>
                </div>
            </div>

            <div class="Queue" v-bind:key="printerQueue.device" v-for="printerQueue in computedPrinterQueues">
                <div class="LeftColumnTitle">[{printerQueue.device}]</div>
                <div v-dragged="onDragged" @click="selectJob(job)"  class="Job" v-bind:key="job.id" v-for="job in printerQueue.jobs" v-bind:class="job.priority" v-bind:style="{ width: job.widthPercentage, left: job.left}">
                    <div class="StartTime" v-if="job.priority == 'New'">
                        <span>[{startTimeHumanReadable}]</span>
                    </div>
                    <div class="StartTime" v-if="job.priority != 'New'">
                        <span>[{job.username}]</span>
                    </div>
                </div>
                <div class="RightColumnOpacity"></div>
            </div>
        </div>
            <!-- <div class="ScrollMargin"></div> -->

        <div class="TempFooter">
            <button v-if="selectedJob!=-1 && reservationInProcess==false" class="button small NavButton" @click="printerError"><span>Printer Error</span></button>
            <button v-if="selectedJob!=-1 && selectedJob.user != this.userId" class="button small NavButton"><span>Contact Author</span></button>
            <!-- <button v-if="selectedJob!=-1 && selectedJob.user != this.userId" class="button small NavButton"><span>Request Slot</span></button> -->
            <button v-if="this.selectedJob!=-1 && this.reservationInProcess==false && this.selectedJob.user==this.userId" class="button small NavButton" @click="deleteJob"><span>Cancel Reservation</span></button>
            <button v-if="reservationInProcess==false" class="button small NavButton" @click="openReservationModal"><span>+</span></button>
            <button v-if="reservationInProcess==true" class="button small NavButton" @click="confirmReservation"><span>Confirm</span></button>
            <button v-if="reservationInProcess==true" class="button small NavButton" @click="cancelReservation"><span>Cancel</span></button>
        </div>
        
    </div>
{% endblock %}

{% block javascript %}
<script src="{% static 'js/ajaxSetup.js' %}"></script>
<script type="module">

    // import ModalReservation from '../../assets/js/ReservationModal';
    // import ModalReservation from './ReservationModal';
    // const ModalReservation = require('../../ReservationModal');

    // import { mapGetters } from 'vuex';
    // import { mapState } from 'vuex';
    // import PrinterErrorModal from '../components/PrinterErrorModal/PrinterErrorModal.vue'
    
    // let modal = require('./ReservationModal');

    let jobReservations = new Vue({
        el: '#job-reservations',
        delimiters: ['[{', '}]'],
        // mounted: function() {
        //     console.log(user.first_name);
        // },
        data: function() {
            return {
                //modal data
                progressPercent: 0,
                filename: '',
                duration: -1,
                filament: -1,
                courseRelated: false,
                lines: '',
                hours: '',
                minutes: '',
                estimating: false,

                newJob: {
                    exists: false,
                    description: '',
                    file: null,
                    duration: -1,
                    date: -1,
                    device: -1,
                    priority: '',
                },
                userId: 1, //not to compute or query from server
                sliderValue: 1,
                startTop: -1,
                startTimeHumanReadable: "",
                selectedJob: -1,
                errorModal: false,
                modalVisibility: false,
                printerQueues: [],
            }
        },
        watch: {
            // file: function() {
                // this.listenToMessages();
                // if (this.file) {
                //     const self = this;
                //     this.verifyFile(this.file, (success) => {
                //     if (success) {
                //         this.textLinesFromFile(this.file, (lines) => {
                //         self.lines = lines;
                //         });
                //     }
                //     });
                // }
                // else {
                //     this.hide();
                // }
            // },
            hours: function() {
                this.duration = this.calculateDuration();
            },
            minutes: function() {
                this.duration = this.calculateDuration();
            },
            modalVisibility: function() {
                if (this.modalVisibility==true) {
                    if (this.file == '') {
                        this.$refs.filename.focus();
                    }
                    else {
                        this.$refs.hours.focus();
                    }
                }
            }
        },
        methods: {
            // MODAL METHODS BELOW

            proceedToPlacement: function() {
                /*
                METHOD 1
                1. get optimal placement time
                2. place uniquely colored segment in timeline at suggested time
                3. allow for dragging of this segment object
                4. signify that the process is not complete!!
                5. verify completion upon drag-finished || verify completion on clicking 'reserve' button!
                */

                this.recommendTimeSlot((result) => {
                    const device = result.device;
                    const startTime = result.startTime;
                    const duration = result.duration;
                    result.priority = "New";
                    console.log('device: ' + device);
                    console.log("startTime: " + startTime);
                    console.log("duration: " + duration);

                    // this.$store.dispatch('addJobToStaging', result);

                    //manage no result coming back or error below
                });
            },
            cancelEstimate: function() {
                this.estimating = false;
                // gcodeProcessorWorker.terminate();
                // gcodeProcessorWorker = undefined;
                // gcodeProcessorWorker.postMessage({
                //     message: 'cleanup',
                // });
            },
            estimatePrintTime: function() {
            //change to cancel estimation button
                this.estimating = true;
                const settings = {"maxSpeed":[100,100,10,100],"maxPrintAcceleration":[1000,1000,100,10000],"maxTravelAcceleration":[1000,1000,100,10000],"maxJerk":[10,10,1,10],"absoluteExtrusion":false,"feedrateMultiplyer":100,"filamentDiameter":1.75,"firmwareRetractLength":2,"firmwareUnretractLength":2,"firmwareRetractSpeed":50,"firmwareUnretractSpeed":50,"firmwareRetractZhop":0,"timeScale":1.01};
                const lines = this.lines;
                // gcodeProcessorWorker.postMessage({
                //     message: 'processGcodes',
                //     data: [lines, settings]
                // });
            },
            resetData: function() { 
                this.hours = '';
                this.minutes = '';
                this.filename = '';
                this.proposal = {};
            },
            makeCourseRelated: function(checked) {
                this.courseRelated = checked;
            },
            verifyFile: function(file, success) {
                const filename = file.name;
                const filename_components = filename.split(".");
                if (filename_components.length == 2) { 
                    const extension = filename_components[1];
                    if (extension == "gcode") {
                    this.filename = filename;
                    success(true);
                    }
                }
                success(false);
            },
            textLinesFromFile: function(file, complete) {
                var reader = new FileReader();
                reader.onload = function(){
                    var lines = this.result.split(/\s*[\r\n]+\s*/g);
                    complete(lines);
                };
                reader.readAsText(file);
            },
            listenToMessages: function() {
                var self = this;
                gcodeProcessorWorker.onmessage = function (e) {
                if ("progress" in e.data) {
                    // self.progressPercent = e.data.progress;
                    console.log("progress: " + e.data.progress);
                } else if ("complete" in e.data) {
                    // document.getElementById("LoadingBar").style.display = "none";
                    // self.progressPercent = 0;
                } else if ("result" in e.data) {
                    const result = e.data.result;
                    const duration = Math.floor(result.printTime);
                    self.estimating = false;
                    self.duration = duration
                    self.filament = result.filamentUsage;

                    self.convertToHrsMins(duration);

                } else if ("layers" in e.data) {
                    // gcodeProcessorWorker.postMessage("cleanup");
                }
            }
        },
        recommendTimeSlot: function(completion) {
            if (this.duration == -1) { return; } 
            const url='http://localhost:1337/reservation-proposal/'+this.duration;
            axios.get(url)
            .then(res => {
                completion(res.data);
                // console.log("job proposal: "+ res.data.device);
                // self.proposal = res.data;
            })
            .catch(err => {
                console.log("error " + err)
                completion(err);
            });
        },
        convertToHrsMins: function(duration) {
            console.log('convert to hrs mins')
            this.hours = Math.floor(duration / 3600);
            this.minutes = Math.floor((duration % 3600) / 60);
        
            // var hoursStr = "";
            // var minStr = "";
            // if (hrs > 0) {
            //   hoursStr = (hrs > 1 ? hrs+" hours" : hrs+" hour");
            // }
            // if (mins > 1) {
            //   minStr = ", " + mins + " minutes";
            // }
            // return hoursStr + minStr;
        },
        calculateDuration: function () {

            //IF both have text values, but only one is greater than zero, return -1

            const convertedHours = isNaN(this.hours) ? 0 : this.hours*3600;
            const convertedMinutes = isNaN(this.minutes) ? 0 : this.minutes*60;
            
            if ((this.hours.length > 0) && (this.minutes.length > 0)) {
                if (isNaN(this.hours) || isNaN(this.minutes)) {
                return -1;
                }
            }
            if ((convertedMinutes+convertedHours) == 0) {
                return -1; 
            }
            else {
                return convertedMinutes+convertedHours; 
            }
        },

            // MODAL METHODS ABOVE


            hideModal: function() {
                console.log("called hide modal");
                this.modalVisibility = false;
            },
            updateQueues: function(queues) {
                queues.forEach(queue => {
                    // console.log("device: " + queue.device);
                    if (queue.jobs.length > 0) {
                        queue.jobs.forEach(job => {
                            // console.log("date: " + job.print_job_date);
                            const startDate = new Date(job.print_job_date);
                            const endDate = new Date(job.print_job_end_date);
                            const duration = (endDate - startDate)/1000;
                            if (job.author == this.userId) {
                                job.priority = "Personal";
                                job.user = job.author;
                            }
                            job.date = startDate.getTime()/1000;
                            job.duration = duration;
                        });
                    }
                });
                this.printerQueues = queues;
            },
            deleteJob: function() {
                $.ajax({
                    type: 'DELETE',
                    url: "/student/printer/job/" + this.selectedJob.id,
                    // probably better that this eventually becomes a django dyanmic url
                    data: {
                        responseType: 'json',
                    },
                    success: (response) => {
                        this.updateQueues(response.queues);
                        this.selectedJob = -1;
                    },
                    error: (response) => {
                        console.log("error");
                    }
                });
            },
            printerError: function() {
                console.log("printer error");
                this.errorModal = true;
            },
            openReservationModal: function() {
                
                this.selectedJob = -1;
                this.modalVisibility = true;
                console.log("open reservation modal " + this.modalVisibility);
                // this.$store.dispatch("showModal");
            },
            hideReservationModal: function() {
                console.log("hideReservationModal");
                this.modalVisibility = false;
            },
            confirmReservation: function() {
                console.log("confirm reservation  new date: " + this.newJob.date);
                // this.$store.dispatch("reserveJob", this.newJob);
                $.ajax({
                    type: 'POST',
                    url: "{% url 'create_job' %}",
                    data: {
                        responseType: 'json',
                        date: 'dynamic date'
                    },
                    success: (response) => {
                        console.log(response.queues);
                    },
                    error: (response) => {
                        console.log("error");
                    }
                });

                console.log("confirm");
            },
            cancelReservation: function() {
                // this.$store.dispatch("queryJobs");
            },
            //END BUTTON JOB FUNCTIONS
            selectJob: function(job) {
                if (this.reservationInProcess) { return; }
                if (this.selectedJob.id == job.id) {
                    this.removeSelectedCSS(this.selectedJob);
                    this.selectedJob = -1;
                }
                else {
                    this.removeSelectedCSS(this.selectedJob);
                    this.selectedJob = job;
                    this.selectedJob.priority = this.selectedJob.priority + " SelectedJob";
                }
            },
            removeSelectedCSS : function(job) {
                if (job != -1) {
                    const newPriorities = job.priority.split(" ").filter((priority) => {
                    return priority != "SelectedJob";
                    });
                    var newPrioritiesString = "";
                    newPriorities.forEach((priority) => {
                        newPrioritiesString += priority + " ";
                    });
                    job.priority = newPrioritiesString;
                }
            },
            convertPositionToDate: function(left) {
                const hours = left/100;
                const secondsFromLeft = hours*3600;

                const startDate = new Date(0);
                startDate.setUTCSeconds(Date.now()/1000);
                startDate.setHours(startDate.getHours());
                startDate.setMinutes(0);
                startDate.setSeconds(0);
                
                return ((startDate.getTime()/1000) + secondsFromLeft);    
            },
            humanReadableTime: function(left) {
                const absoluteDateSeconds = this.convertPositionToDate(left);
                // console.log("absolute seconds: " + absoluteDateSeconds);
                const date = new Date(0);
                date.setUTCSeconds(absoluteDateSeconds);
                var hours = date.getHours();
                var minutes = date.getMinutes();
                if (hours < 10) {
                    hours = '0' + hours;
                }
                if (minutes < 10) {
                    minutes = '0' + minutes;
                }
                this.startTimeHumanReadable = hours+":"+minutes;
            },
            onDragged({ el, deltaX, deltaY, _clientX, _clientY, _offsetX, _offsetY, first, last }) {
                // QUIT IF NOT A NEW JOB PROPOSAL
                var shouldContinue = false;
                el.classList.forEach((className) => {
                    if (className == "New") { shouldContinue = true; }
                })
                if (shouldContinue ==  false) { return; }

                // BULLSHIT
                if ((_clientX == (1/_clientY)) && (_offsetX == _offsetY)) {console.log('surprise');}
                // BULLSHIT

                var l = +window.getComputedStyle(el)['left'].slice(0, -2) || 0;
                var t = +window.getComputedStyle(el)['top'].slice(0, -2) || 0;

                if (first) {
                    this.startTop = el.style.top;
                    this.printerQueues.forEach(queue => {  
                        queue.jobs.forEach(job => {
                            if (job.priority == "New") {
                                this.job = job;
                                // this.device = queue.device;
                            }
                        });
                    });
                    
                    el.style.zIndex = "500";
                    return
                }
                if (last) { //COMPLETE DRAG
                    
                    var deltaYvertical = parseFloat(window.getComputedStyle(el).top);
                    //THERE IS A difference between moving one space and moving two!

                    var distanceToOvercome = parseFloat(window.getComputedStyle(el.parentNode).height)/2+ parseFloat(window.getComputedStyle(el.parentNode).marginBottom)/2;
                    var rowChange = 0;
                    var sign = deltaYvertical < 0 ? -1 : 1;
                    deltaYvertical = Math.abs(deltaYvertical);
                    while (deltaYvertical > distanceToOvercome) {
                        rowChange++;
                        distanceToOvercome += parseFloat(window.getComputedStyle(el.parentNode).height)+ parseFloat(window.getComputedStyle(el.parentNode).marginBottom);
                    }
                    rowChange *= sign;
                    const lastDevice = this.newJob.device;
                    var newDevice = lastDevice + rowChange;
                    if (newDevice < 1) {
                        newDevice = 1;
                    }
                    else  if (newDevice > this.printerQueues.length) {
                        newDevice = this.printerQueues.length;
                    }

                    // console.log('deltaY ' + deltaYvertical);
                    // console.log('rowChange ' + rowChange);

                    // get job from priority, get device, get new device from transformation
                    
                    var updatedJob = this.newJob;
                    updatedJob.device = newDevice;
                    updatedJob.date = this.convertPositionToDate(parseFloat(el.style.left));
                    
                    if (lastDevice == newDevice) {
                        console.log("no queue change");
                        el.style.top = this.startTop;
                    }
                // else {
                    var updatedQueues = this.printerQueues;
                    var remainingJobs;

                    //get jobs regular jobs
                    this.printerQueues.forEach((queue) => {
                        if (queue.device == lastDevice) {
                            remainingJobs = queue.jobs.filter((job) => {
                                return (job.priority != "New");
                            });
                        }
                    });

                    console.log("remaining job count: " + remainingJobs.length);

                    //update previous and new queue
                    updatedQueues.forEach((queue) => {
                        if (queue.device == lastDevice) {
                            queue.jobs = remainingJobs;
                        }
                        if (queue.device == newDevice) {
                            queue.jobs.push(this.newJob);
                        }
                    });
                    // this.$store.dispatch("updateQueues", updatedQueues);
                    // this.$store.dispatch("updateNewJob", updatedJob.date);

                    //RESET Z-Index after animation
                    const jobStyle = el.style;
                    jobStyle.zIndex = "0";
                    
                    this.startTimeHumanReadable = '';
                    
                    return;
                }
                // el.style.left = l + deltaX + 'px';
                //Update date
                
                el.style.left = l + deltaX + 'px';
                el.style.top = t + deltaY + 'px';
                this.humanReadableTime(parseFloat(el.style.left));
            }
        },
        computed: {
            // ...mapState(['sliderValue', 'printerQueues', 'newJob', 'modalVisibility']),
            // ...mapGetters(['username', 'is_authenticated', 'userId']),
            otherButtons: function() {
                return (this.selectedJob!=-1 && this.reservationInProcess==false);
            },
            myButtons: function() {
                return (selectedJob!=-1 && selectedJob.user != this.userId);
            },
            computedPrinterQueues: function() {
                const computedPrinterQueue = this.printerQueues;
                computedPrinterQueue.forEach(printerQueue => {
                    printerQueue.jobs.forEach(job => {
                        /*

                        - this.sliderValue is simply the time between intervals
                        - time elements are 2 hour intervals at 100px. 2hours/100px
                        - (job.duration in seconds) 
                        - ratio is this.sliderWidth per 10% -> this.sliderValue/.10
                        Percentage = (job.duration * 10%) / (this.sliderValue * 3600)
                        -  duration is in seconds?
                        -  (50px/ 1hour) * job.duration * 1hour/3600seconds
                        */
                            
                        
                        job.widthPercentage = (50 * job.duration / 3600) + 'px';
                        
                        const startDate = new Date(0);
                        startDate.setUTCSeconds(Date.now()/1000);
                        startDate.setHours(startDate.getHours());
                        startDate.setMinutes(0);
                        startDate.setSeconds(0);
                        
                        const deltaTime = job.date - (startDate.getTime()/1000);
                        //deltaTime is number of seconds between now and job
                        //sliderValue is time interval
                        const deltaTimeInHours = deltaTime/3600; //3600 seconds in an hour
                        
                        // const deltaTimeInHoursInPixels = deltaTimeInHours * 50px/hour
                        const deltaTimeInHoursInPixels = (deltaTimeInHours * 100) + 'px';
                        job.left = deltaTimeInHoursInPixels;
                        
                        //make special color for personal
                        if (job.user == this.userId) {
                            job.priority = "Personal";
                        }
                    });
                });
                return computedPrinterQueue;
            },
            timeline: function() {
                    /*
                    important that this accomdates css flex
                    starting with 2 hour intervals per 100px
                    */
                    var dateForTimeElement = new Date();
                    const dayString = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
                    const currentHour = (new Date()).getHours();
                    const currentSeconds = Date.now()/1000; //seems to be millis
                    var endDateSeconds = currentSeconds;

                    this.printerQueues.forEach(printerQueue => {
                        printerQueue.jobs.forEach(job => {
                            const jobEndSeconds = Number(job.duration) + Number(job.date);
                            if (jobEndSeconds > endDateSeconds) {
                                endDateSeconds = jobEndSeconds;
                            }
                        });
                    });

                    // add one page width of seconds at the end. inverse(50 pixels / 1 hour) * 3600 seconds / hour;

                    // extra width of page in seconds?
                    const pageWidthInSeconds = window.innerWidth * (3600/50);

                    // console.log('pageWidth: '+ pageWidthInSeconds);



                    // const extraSeconds = 3600*12;

                    const timelineDurationSeconds = (endDateSeconds - currentSeconds) + pageWidthInSeconds;
                    
                    // console.log('timeline duration: ' + timelineDurationSeconds);
                    /* if timelineDurationSeconds < full page of time
                        add appropriate # hours
                    */
                    // const timelineNumberOfHours = (endDateSeconds - currentSeconds)/(this.sliderValue*3600);
                    var timelineObject = [];
                    timelineObject.push({
                        time: currentHour,
                        date: ""
                    }); 
                    /*
                    timelineObject = [
                        22,
                        23,
                        0,
                        1,
                    ]
                    */
                    //should always have enough hours for one day?, but more hours when needed. Width of spacing between times is to be predefined
                    
                    var i = 1;
                    var sumTime = 0;
                    while ( i <= 11 || sumTime <= timelineDurationSeconds ) {
                        sumTime += Number(this.sliderValue) * 3600;
                        const lastNumber = timelineObject[timelineObject.length-1].time;
                        const tentativeNextNumber = Number(lastNumber) + Number(this.sliderValue);
                        if (tentativeNextNumber >= 24) {
                            //add day here
                            timelineObject.push({
                                time: Number(tentativeNextNumber-24),
                                date: dayString[dateForTimeElement.getDay()] + " " + dateForTimeElement.getDate()
                            });
                            dateForTimeElement.setDate(dateForTimeElement.getDate() + 1);
                        }
                        else {
                            timelineObject.push({
                                time: tentativeNextNumber,
                                date: (i == 1) ? (dayString[dateForTimeElement.getDay()] + " " + dateForTimeElement.getDate()) : ""
                            });
                            if (i == 1) { 
                                dateForTimeElement.setDate(dateForTimeElement.getDate() + 1);
                            }
                        }
                        i++;
                    }
                    timelineObject = timelineObject.map(numObj => {
                        return {
                            time: (numObj.time < 10) ? ('0' + numObj.time + ':00') : (''+ numObj.time + ':00'),
                            date: numObj.date
                        }
                    });
                    //remove first time for clarity (temporarily for testing)
                    timelineObject[0] = {};
                    return timelineObject;
            },
            reservationInProcess: function() {
                var inProcess = false;

                this.printerQueues.forEach((queue) => {
                    queue.jobs.forEach((job) => {
                        if (job.priority == "New") { inProcess = true; }
                    });
                });
                return inProcess;
            }
        },
        created() {
            // SETTING USER ID
            const textData = document.getElementById('user-data').textContent;
            this.userId = JSON.parse(textData);
            
            // QUERYING JOB DATA
            $.ajax({
                    type: 'GET',
                    url: "{% url 'get_job_queues' %}",
                    data: {
                        responseType: 'json',
                    },
                    success: (response) => {
                        // console.log(response.queues);
                        this.updateQueues(response.queues);
                    },
                    error: (response) => {
                        console.log("error");
                    }
            });
            
            $.ajax({
                    type: 'POST',
                    url: "{% url 'recommend_job' %}",
                    data: {
                        'duration': '5000',
                    },
                    success: (response) => {
                        console.log("queues retrieved! " + response.duration);
                    },
                    error: (response) => {
                        console.log("error");
                    }
            });
        } 
    });     
</script>
{% endblock %} 